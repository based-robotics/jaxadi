from casadi import (
    OP_ACOS,
    OP_ACOSH,
    OP_ADD,
    OP_AND,
    OP_ASIN,
    OP_ASINH,
    OP_ASSIGN,
    OP_ATAN,
    OP_ATAN2,
    OP_ATANH,
    OP_CEIL,
    OP_CONST,
    OP_CONSTPOW,
    OP_COPYSIGN,
    OP_COS,
    OP_COSH,
    OP_DIV,
    OP_EQ,
    OP_ERF,
    OP_EXP,
    OP_FABS,
    OP_FLOOR,
    OP_FMAX,
    OP_FMIN,
    OP_FMOD,
    OP_IF_ELSE_ZERO,
    OP_INPUT,
    OP_INV,
    OP_LE,
    OP_LOG,
    OP_LT,
    OP_MUL,
    OP_NE,
    OP_NEG,
    OP_NOT,
    OP_OR,
    OP_OUTPUT,
    OP_POW,
    OP_SIGN,
    OP_SIN,
    OP_SINH,
    OP_SQ,
    OP_SQRT,
    OP_SUB,
    OP_TAN,
    OP_TANH,
    OP_TWICE,
)

OP_JAX_DICT = {
    OP_ASSIGN: "\n    work = work.at[{0}].set(work[{1}])",
    OP_ADD: "\n    work = work.at[{0}].set(work[{1}] + work[{2}])",
    OP_SUB: "\n    work = work.at[{0}].set(work[{1}] - work[{2}])",
    OP_MUL: "\n    work = work.at[{0}].set(work[{1}] * work[{2}])",
    OP_DIV: "\n    work = work.at[{0}].set(work[{1}] / work[{2}])",
    OP_NEG: "\n    work = work.at[{0}].set(-work[{1}])",
    OP_EXP: "\n    work = work.at[{0}].set(jnp.exp(work[{1}]))",
    OP_LOG: "\n    work = work.at[{0}].set(jnp.log(work[{1}]))",
    OP_POW: "\n    work = work.at[{0}].set(jnp.power(work[{1}], work[{2}]))",
    OP_CONSTPOW: "\n    work = work.at[{0}].set(jnp.power(work[{1}], work[{2}]))",
    OP_SQRT: "\n    work = work.at[{0}].set(jnp.sqrt(work[{1}]))",
    OP_SQ: "\n    work = work.at[{0}].set(work[{1}] * work[{2}])",
    OP_TWICE: "\n    work = work.at[{0}].set(2 * work[{1}])",
    OP_SIN: "\n    work = work.at[{0}].set(jnp.sin(work[{1}]))",
    OP_COS: "\n    work = work.at[{0}].set(jnp.cos(work[{1}]))",
    OP_TAN: "\n    work = work.at[{0}].set(jnp.tan(work[{1}]))",
    OP_ASIN: "\n    work = work.at[{0}].set(jnp.arcsin(work[{1}]))",
    OP_ACOS: "\n    work = work.at[{0}].set(jnp.arccos(work[{1}]))",
    OP_ATAN: "\n    work = work.at[{0}].set(jnp.arctan(work[{1}]))",
    OP_LT: "\n    work = work.at[{0}].set(work[{1}] < work[{2}])",
    OP_LE: "\n    work = work.at[{0}].set(work[{1}] <= work[{2}])",
    OP_EQ: "\n    work = work.at[{0}].set(work[{1}] == work[{2}])",
    OP_NE: "\n    work = work.at[{0}].set(work[{1}] != work[{2}])",
    OP_NOT: "\n    work = work.at[{0}].set(jnp.logical_not(work[{1}]))",
    OP_AND: "\n    work = work.at[{0}].set(jnp.logical_and(work[{1}], work[{2}]))",
    OP_OR: "\n    work = work.at[{0}].set(jnp.logical_or(work[{1}], work[{2}]))",
    OP_FLOOR: "\n    work = work.at[{0}].set(jnp.floor(work[{1}]))",
    OP_CEIL: "\n    work = work.at[{0}].set(jnp.ceil(work[{1}]))",
    OP_FMOD: "\n    work = work.at[{0}].set(jnp.fmod(work[{1}], work[{2}]))",
    OP_FABS: "\n    work = work.at[{0}].set(jnp.abs(work[{1}]))",
    OP_SIGN: "\n    work = work.at[{0}].set(jnp.sign(work[{1}]))",
    OP_COPYSIGN: "\n    work = work.at[{0}].set(jnp.copysign(work[{1}], work[{2}]))",
    OP_IF_ELSE_ZERO: "\n    work = work.at[{0}].set(jnp.where(work[{1}] == 0, 0, work[{2}]))",
    OP_ERF: "\n    work = work.at[{0}].set(jax.scipy.special.erf(work[{1}]))",
    OP_FMIN: "\n    work = work.at[{0}].set(jnp.minimum(work[{1}], work[{2}]))",
    OP_FMAX: "\n    work = work.at[{0}].set(jnp.maximum(work[{1}], work[{2}]))",
    OP_INV: "\n    work = work.at[{0}].set(1.0 / work[{1}])",
    OP_SINH: "\n    work = work.at[{0}].set(jnp.sinh(work[{1}]))",
    OP_COSH: "\n    work = work.at[{0}].set(jnp.cosh(work[{1}]))",
    OP_TANH: "\n    work = work.at[{0}].set(jnp.tanh(work[{1}]))",
    OP_ASINH: "\n    work = work.at[{0}].set(jnp.arcsinh(work[{1}]))",
    OP_ACOSH: "\n    work = work.at[{0}].set(jnp.arccosh(work[{1}]))",
    OP_ATANH: "\n    work = work.at[{0}].set(jnp.arctanh(work[{1}]))",
    OP_ATAN2: "\n    work = work.at[{0}].set(jnp.arctan2(work[{1}], work[{2}]))",
    OP_CONST: "\n    work = work.at[{0}].set({1:.16f})",
    OP_INPUT: "\n    work = work.at[{0}].set(inputs[{1}][{2}, {3}])",
    OP_OUTPUT: "\n    outputs[{0}] = outputs[{0}].at[{1}, {2}].set(work[{3}][0])",
}

OP_JAX_VALUE_DICT = {
    OP_ASSIGN: "work[{0}]",
    OP_ADD: "work[{0}] + work[{1}]",
    OP_SUB: "work[{0}] - work[{1}]",
    OP_MUL: "work[{0}] * work[{1}]",
    OP_DIV: "work[{0}] / work[{1}]",
    OP_NEG: "-work[{0}]",
    OP_EXP: "jnp.exp(work[{0}])",
    OP_LOG: "jnp.log(work[{0}])",
    OP_POW: "jnp.power(work[{0}], work[{1}])",
    OP_CONSTPOW: "jnp.power(work[{0}], work[{1}])",
    OP_SQRT: "jnp.sqrt(work[{0}])",
    OP_SQ: "work[{0}] * work[{0}]",
    OP_TWICE: "2 * work[{0}]",
    OP_SIN: "jnp.sin(work[{0}])",
    OP_COS: "jnp.cos(work[{0}])",
    OP_TAN: "jnp.tan(work[{0}])",
    OP_ASIN: "jnp.arcsin(work[{0}])",
    OP_ACOS: "jnp.arccos(work[{0}])",
    OP_ATAN: "jnp.arctan(work[{0}])",
    OP_LT: "work[{0}] < work[{1}]",
    OP_LE: "work[{0}] <= work[{1}]",
    OP_EQ: "work[{0}] == work[{1}]",
    OP_NE: "work[{0}] != work[{1}]",
    OP_NOT: "jnp.logical_not(work[{0}])",
    OP_AND: "jnp.logical_and(work[{0}], work[{1}])",
    OP_OR: "jnp.logical_or(work[{0}], work[{1}])",
    OP_FLOOR: "jnp.floor(work[{0}])",
    OP_CEIL: "jnp.ceil(work[{0}])",
    OP_FMOD: "jnp.fmod(work[{0}], work[{1}])",
    OP_FABS: "jnp.abs(work[{0}])",
    OP_SIGN: "jnp.sign(work[{0}])",
    OP_COPYSIGN: "jnp.copysign(work[{0}], work[{1}])",
    OP_IF_ELSE_ZERO: "jnp.where(work[{0}] == 0, 0, work[{1}])",
    OP_ERF: "jax.scipy.special.erf(work[{0}])",
    OP_FMIN: "jnp.minimum(work[{0}], work[{1}])",
    OP_FMAX: "jnp.maximum(work[{0}], work[{1}])",
    OP_INV: "1.0 / work[{0}]",
    OP_SINH: "jnp.sinh(work[{0}])",
    OP_COSH: "jnp.cosh(work[{0}])",
    OP_TANH: "jnp.tanh(work[{0}])",
    OP_ASINH: "jnp.arcsinh(work[{0}])",
    OP_ACOSH: "jnp.arccosh(work[{0}])",
    OP_ATANH: "jnp.arctanh(work[{0}])",
    OP_ATAN2: "jnp.arctan2(work[{0}], work[{1}])",
    OP_CONST: "{0:.16f}",
    OP_INPUT: "inputs[{0}, {1}, {2}]",
    OP_OUTPUT: "work[{0}][0]",
}
